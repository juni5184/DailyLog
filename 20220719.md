# 2022.07.19

인프런 - CS의 정석 강의 듣고 정리
- 디자인 패턴
- 싱글톤 패턴
- 의존성 주입
- 팩토리 패턴
- 이터레이터 패턴
- 전략 패턴

### 디자인 패턴

디자인 패턴 : 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 들을 이용하여 해결할 수 있도록 하나의 ‘규약’ 형태로 만들어 놓은 것 (ex. spring, Vue, React)

라이브러리와 프레임워크 차이

라이브러리

- 공통으로 사용될 수 있는 특정한 기능들을 모듈화 한 것
- 폴더명, 파일명에 대한 규칙이 없고 프레임워크에 비해 자유롭다.
- ex) 무언가를 자를 때 ‘도구’인 ‘가위’를 이용해서 ‘내가’ 직접 컨트롤하여 자르는데 라이브러리는 이와 비슷하다.

프레임워크

- 공통으로 사용될 수 있는 특정한 기능들을 모듈화한 것
- 폴더명, 파일명에 대한 규칙이 있으며 라이브러리에 비해 좀 더 엄격하다.
- 다른 곳으로 이동할 때 ‘도구’인 비행기를 타고 이동하지만 ‘비행기’가 컨트롤하고 나는 가만히 앉아 있어야 한다. 프레임워크는 이와 비슷하다.

### 싱글톤 패턴

싱글톤 패턴(singleton pattern)은 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴

보통 데이터베이스 연결 모듈에 많이 사용한다. 하나의 인스턴스를 만들어 놓고 해당 인스턴스를 다른 모듈들이 공유하며 사용하기 때문에 인스턴스를 생성할 때 드는 비용이 줄어드는 장점이 있다. 하지만 의존성이 높아진다는 단점이 있다.

싱글톤 패턴은 TDD(Test Driven Development)를 할 때 걸림돌이 된다.

TDD를 할 때 단위 테스트를 주로 하는데, 단위 테스트는 테스트가 서로 독립적이어야 하며 테스트를 어떤 순서로든 실행할 수 있어야 한다.

하지만 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 ‘독립적인’ 인스턴스를 만들기가 어렵다.

I/O Bound : 네트워크나 데이터베이스 연결에 관한 작업 → 비용이 많이 들음

### 의존성 주입

싱글톤 패턴은 사용하기가 쉽고 굉장히 실용적이지만 모듈 간의 결합을 강하게 만들 수 있다는 단점이 있다. 이때 의존성 주입(DI, Dependency Injection)을 통해 모듈간의 결합을 조금 더 느슨하게 만들어 해결할 수 있다.

의존성이란 종속성이라고도 하며 A가 B에 의존성이 있다는 것은 B의 변경 사항에 대해 A 또한 변해야 된다는 것을 의미한다.

메인 모듈 (main module)이 ‘직접’하위 모듈에 대한 의존성을 주기보다는 중간에 의존성 주입자 (dependency injector)가 이 부분을 가로채 메인 모듈이 ‘간접’적으로 의존성을 주입하는 방식이다.

이를 통해 메인 모듈 (상위 모듈)은 하위 모듈에 대한 의존성이 떨어지게 된다. 참고로 이를 ‘디커플링 된다’고도 한다. “서비스”를 사용하려는 수신객체(클라이언트)가 해당 서비스의 구성방법을 알 필요가 없게 하는 것 

종속성 주입(DI)은 컴파일타임이 아닌 런타임에 종속성을 해결하는 데 사용된다.

의존성 주입은 프레임워크가 아닌 디자인패턴이다. 이는 IoC (Inversion of Control)라고 하는 보다 일반적인 소프트웨어 개념을 구현하는 한 가지 방법이다. (SOLID 디자인 원칙의 일부)

**무언가 쉽게 교체**할 수 있게 만든다.

의존성 주입의 장점

- 모듈들을 쉽게 교체할 수 있는 구조가 되어 테스팅하기 쉽고 마이그레이션하기도 수월하다.
- 구현할 때 추상화 레이어를 넣고 이를 기반으로 구현체를 넣어 주기 때문에 애플리케이션의 의존성 방향이 일관되고, 애플리케이션을 쉽게 추론할 수 있으며, 모듈간의 관계들이 조금 더 명확해진다.

의존성 주입의 단점

- 모듈들이 더욱더 분리되므로 클래스 수가 늘어나 복잡성이 증가될 수 있으며 약간의 런타임 패널티가 생기기도 한다.
- 종속성은 런타임에 해결되기 때문에 종속성 오류는 컴파일 시간에 포착할 수 없다.

### 팩토리 패턴

팩토리 패턴 (factory pattern)은 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴이자 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴이다.

상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결합을 가지며 상위 클래스에서는 인스턴스 생성 방식에 대해 전혀 알 필요가 없기 때문에 더 많은 유연성을 갖게 된다.

객체 생성 로직이 따로 떼어져 있기 때문에 코드를 리팩터링하더라도 한 곳만 고칠 수 있게 되어 유지보수성이 증가한다.

### 이터레이터 패턴

이터레이터 패턴(iterator pattern)은 이터레이터(iterator)를 사용하여 컬렉션(collection)의 요소들에 접근하는 디자인 패턴이다.

이를 통해 순회할 수 있는 각기 다른 자료형의 구조와는 상관없이 이터레이터라는 **하나의 인터페이스로 순회가 가능**해서 코드의 효율화, 숫자형 index가 아닌 string 등 다양한 인덱스를 기반으로 순회를 쉽게 할 수 있다.

- 컬렉션 = 컨테이너라고도 하고, 동일한 요소들의 집합을 말한다. 배열, 트리 등을 지칭함.
- 이터레이터 프로토콜 : 이터러블한 객체들을 순회할 때 쓰이는 규칙
- 이터러블한 객체 : 반복 가능한 객체로 배열을 일반화한 객체

### 전략 패턴

전략 패턴(strategy pattern)은 정책 패턴(policy pattern)이라고도 하며, 객체의 행위를 바꾸고 싶은 경우 ‘직접’ 수정하지 않고 전략이라고 부르는 ‘캡슐화한 알고리즘’을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴이다.

- 컨텍스트 : 프로그래밍에서의 컨텍스트는 상황, 맥락, 문맥을 의미하며 개발자가 어떠한 작업을 완료하는 데 필요한 모든 관련 정보를 말한다.